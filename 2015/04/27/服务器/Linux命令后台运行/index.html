<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Linux命令后台运行 | QiangBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="转自北国的雨的cnblogs，我整理成markdown格式

有两种方式： 
command &amp;amp; ： 后台运行，你关掉终端会停止运行
nohup command &amp;amp; ： 后台运行，你关掉终端也会继续运行
简介Linux/Unix 区别于微软平台最大的优点就是真正的多用户，多任务。因此在任务管理上也有别具特色的管理思想。我们知道，在 Windows 上面，我们要么让一个程序作为服务在">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux命令后台运行">
<meta property="og:url" content="http://zgr0629.github.io/2015/04/27/服务器/Linux命令后台运行/index.html">
<meta property="og:site_name" content="QiangBlog">
<meta property="og:description" content="转自北国的雨的cnblogs，我整理成markdown格式

有两种方式： 
command &amp;amp; ： 后台运行，你关掉终端会停止运行
nohup command &amp;amp; ： 后台运行，你关掉终端也会继续运行
简介Linux/Unix 区别于微软平台最大的优点就是真正的多用户，多任务。因此在任务管理上也有别具特色的管理思想。我们知道，在 Windows 上面，我们要么让一个程序作为服务在">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux命令后台运行">
<meta name="twitter:description" content="转自北国的雨的cnblogs，我整理成markdown格式

有两种方式： 
command &amp;amp; ： 后台运行，你关掉终端会停止运行
nohup command &amp;amp; ： 后台运行，你关掉终端也会继续运行
简介Linux/Unix 区别于微软平台最大的优点就是真正的多用户，多任务。因此在任务管理上也有别具特色的管理思想。我们知道，在 Windows 上面，我们要么让一个程序作为服务在">
  
    <link rel="alternative" href="/atom.xml" title="QiangBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">QiangBlog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://zgr0629.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-服务器/Linux命令后台运行" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/27/服务器/Linux命令后台运行/" class="article-date">
  <time datetime="2015-04-27T06:51:00.000Z" itemprop="datePublished">2015-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux命令后台运行
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>转自<a href="http://www.cnblogs.com/lwm-1988/archive/2011/08/20/2147299.html" target="_blank" rel="external">北国的雨</a>的cnblogs，我整理成markdown格式</p>
</blockquote>
<p>有两种方式： </p>
<pre><code><span class="command"><span class="keyword">command</span> &amp; ： 后台运行，你关掉终端会停止运行</span>
nohup <span class="command"><span class="keyword">command</span> &amp; ： 后台运行，你关掉终端也会继续运行</span>
</code></pre><h2 id="简介">简介</h2><p>Linux/Unix 区别于微软平台最大的优点就是真正的多用户，多任务。因此在任务管理上也有别具特色的管理思想。<br>我们知道，在 Windows 上面，我们要么让一个程序作为服务在后台一直运行，要么停止这个服务。而不能让程序在前台后台之间切换。而 Linux 提供了 fg 和bg 命令，让你轻松调度正在运行的任务。假设你发现前台运行的一个程序需要很长的时间，但是需要干其他的事情，你就可以用 Ctrl-Z ，挂起这个程序，然后可以看到系统提示：</p>
<pre><code>[<span class="number">1</span>]+ Stopped <span class="regexp">/root/</span>bin<span class="regexp">/rsync.sh</span>
</code></pre><p>然后我们可以把程序调度到后台执行：（bg 后面的数字为作业号）</p>
<pre><code><span class="id">#bg</span> <span class="number">1</span>
[<span class="number">1</span>]+ /root/bin/rsync<span class="class">.sh</span> &amp;
</code></pre><p>用 jobs 命令查看正在运行的任务：</p>
<pre><code><span class="id">#jobs</span>    
[<span class="number">1</span>]+ Running /root/bin/rsync<span class="class">.sh</span> &amp;
</code></pre><p>如果想把它调回到前台运行，可以用</p>
<pre><code><span class="comment">#fg 1</span>
/<span class="literal">root</span>/bin/rsync.sh
</code></pre><p>这样，你在控制台上就只能等待这个任务完成了。</p>
<p><strong><em>&amp;</em></strong> 将指令丢到后台中去执行<br><strong><em>[ctrl]+z</em></strong> 將前台任务丟到后台中暂停<br><strong><em>jobs</em></strong> 查看后台的工作状态<br><strong><em>fg %jobnumber</em></strong> 将后台的任务拿到前台来处理<br><strong><em>bg %jobnumber</em></strong> 将任务放到后台中去处理<br><strong><em>kill</em></strong> 管理后台的任务</p>
<h3 id="&amp;">&amp;</h3><p>在Linux中，当在前台运行某个作业时，终端被该作业占据；而在后台运行作业时，它不会占据终端。可以使用&amp;命令把作业放到后台执行。实际上，这样是将命令放入到一个作业队列中了：</p>
<pre><code>$ ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
[1] 17208

$ jobs -<span class="keyword">l</span>
[1]+ 17208 Running                 ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
</code></pre><p>在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：</p>
<pre><code>command &gt;<span class="keyword">out</span>.<span class="keyword">file</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;
</code></pre><p>在上面的例子中，2&gt;&amp;1表示所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。 当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。<br>例：查找名为“httpd.conf”的文件，并把所有标准输出和错误输出重定向到find.dt的文件中： </p>
<pre><code># <span class="built_in">find</span> /etc/httpd/ -name <span class="string">"httpd.conf"</span> -<span class="built_in">print</span> &gt;<span class="built_in">find</span>.dt <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp; 
[<span class="number">2</span>] <span class="number">7832</span> 
</code></pre><p>成功提交该命令之后，系统给出了它的进程号7832。 对于已经在前台执行的命令，也可以重新放到后台执行，首先按ctrl+z暂停已经运行的进程，然后使用bg命令将停止的作业放到后台运行，例如对正在前台执行的tesh.sh使用ctrl+z挂起它：</p>
<pre><code>$ ./<span class="keyword">test</span>.<span class="keyword">sh</span>
[1]+ Stopped                 ./<span class="keyword">test</span>.<span class="keyword">sh</span>

$ bg %1
[1]+ ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;

$ jobs -<span class="keyword">l</span>
[1]+ 22794 Running                 ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
</code></pre><p>但是如上方到后台执行的进程，其父进程还是当前终端shell的进程，而一旦父进程退出，则会发送hangup信号给所有子进程，子进程收到hangup以后也会退出。如果我们要在退出shell的时候继续运行进程，则需要使用nohup忽略hangup信号，或者setsid将将父进程设为init进程(进程号为1)</p>
<pre><code>$ echo $$
21734

$ nohup ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
[1] 29016

$ ps -ef | grep <span class="keyword">test</span>
515      29710 21734 0 11:47 pts/12   00:00:00 /bin/<span class="keyword">sh</span> ./<span class="keyword">test</span>.<span class="keyword">sh</span>
515      29713 21734 0 11:47 pts/12   00:00:00 grep <span class="keyword">test</span>
$ setsid ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
[1] 409

$ ps -ef | grep <span class="keyword">test</span>
515        410     1 0 11:49 ?        00:00:00 /bin/<span class="keyword">sh</span> ./<span class="keyword">test</span>.<span class="keyword">sh</span>
515        413 21734 0 11:49 pts/12   00:00:00 grep <span class="keyword">test</span>
</code></pre><p>上面的试验演示了使用nohup/setsid加上&amp;使进程在后台运行，同时不受当前shell退出的影响。那么对于已经在后台运行的进程，该怎么办呢？可以使用disown命令：</p>
<pre><code>$ ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;
[1] 2539

$ jobs -<span class="keyword">l</span>
[1]+ 2539 Running                 ./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;

$ disown -<span class="keyword">h</span> %1

$ ps -ef | grep <span class="keyword">test</span>
515        410     1 0 11:49 ?        00:00:00 /bin/<span class="keyword">sh</span> ./<span class="keyword">test</span>.<span class="keyword">sh</span>
515       2542 21734 0 11:52 pts/12   00:00:00 grep <span class="keyword">test</span>
</code></pre><p>另外还有一种方法，即使将进程在一个subshell中执行，其实这和setsid异曲同工。方法很简单，将命令用括号() 括起来即可：</p>
<pre><code>$ (./<span class="keyword">test</span>.<span class="keyword">sh</span> &amp;)

$ ps -ef | grep <span class="keyword">test</span>
515        410     1 0 11:49 ?        00:00:00 /bin/<span class="keyword">sh</span> ./<span class="keyword">test</span>.<span class="keyword">sh</span>
515      12483 21734 0 11:59 pts/12   00:00:00 grep <span class="keyword">test</span>
</code></pre><blockquote>
<p>注：本文试验环境为Red Hat Enterprise Linux AS release 4 (Nahant Update 5),shell为/bin/bash，不同的OS和shell可能命令有些不一样。例如AIX的ksh，没有disown，但是可以使用nohup -p PID来获得disown同样的效果。</p>
</blockquote>
<p>还有一种更加强大的方式是使用screen，首先创建一个断开模式的虚拟终端，然后用-r选项重新连接这个虚拟终端，在其中执行的任何命令，都能达到nohup的效果，这在有多个命令需要在后台连续执行的时候比较方便：</p>
<pre><code>$ screen -dmS screen_test

$ screen -<span class="type">list</span>
There <span class="keyword">is</span> a screen <span class="function_start"><span class="keyword">on</span></span>:
        <span class="number">27963.</span>screen_test       (Detached)
<span class="number">1</span> Socket <span class="keyword">in</span> /tmp/uscreens/S-jiangfeng.

$ screen -r screen_test
</code></pre><h2 id="nohup">nohup</h2><p>如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户之后继续运行相应的进程。nohup就是不挂起的意思( no hang up)。 该命令的一般形式为： </p>
<pre><code><span class="title">nohup</span> conmmand &amp;
</code></pre><p>如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</p>
<pre><code>nohup <span class="command"><span class="keyword">command</span> &gt; <span class="title">myout</span>.<span class="title">file</span> <span class="title">2</span>&gt;&amp;<span class="title">1</span> </span>
</code></pre><p>在上面的例子中，输出被重定向到myout.file文件中。</p>
<h2 id="、-*，？，[…]，[!…]等">、.*，？，[…]，[!…]等</h2><p>下面就是这些特殊字符： </p>
<ul>
<li>*匹配文件名中的任何字符串，包括空字符串。 </li>
<li>？ 匹配文件名中的任何单个字符。 </li>
<li>[…] 匹配[ ]中所包含的任何字符。 </li>
<li>[!…] 匹配[ ]中非感叹号！之后的字符。 </li>
<li>当s h e l l遇到上述字符时，就会把它们当作特殊字符，而不是文件名中的普通字符，这样用户就可以用它们来匹配相应的文件名。</li>
</ul>
<p><strong><em>一些例子</em></strong></p>
<ol>
<li><p>列出以i或o开头的文件名：</p>
<pre><code><span class="id">#ls</span> <span class="attr_selector">[io]</span>*
</code></pre></li>
<li><p>列出log.开头、后面跟随一个数字、然后可以是任意字符串的文件名：</p>
<pre><code><span class="id">#ls</span> <span class="tag">log</span>.<span class="attr_selector">[0-9]</span>* 
</code></pre></li>
<li><p>与例二相反，列出log.开头、后面不跟随一个数字、然后可以是任意字符串的文件名：</p>
<pre><code><span class="id">#ls</span> <span class="tag">log</span>.<span class="attr_selector">[!0-9]</span>* 
</code></pre></li>
<li><p>列出所有以LPS开头、中间可以是任何两个字符，最后以1结尾的文件名：</p>
<pre><code><span class="preprocessor">#ls LPS??1</span>
</code></pre></li>
<li><p>列出所有以大写字母开头的文件名：</p>
<pre><code>$ ls [<span class="literal">A</span>-Z]*
</code></pre></li>
<li><p>列出所有以. 开头的文件名（隐含文件，例如. profile、.rhosts、.histo ry等）：</p>
<pre><code><span class="variable">$ </span>ls .*
</code></pre></li>
</ol>
<h2 id="其他相关命令：">其他相关命令：</h2><ul>
<li>jobs：查看当前有多少在后台运行的命令</li>
<li>fg：将后台中的命令调至前台继续运行。如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</li>
<li>bg：将一个在后台暂停的命令，变成继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)</li>
</ul>
<h2 id="杀死进程">杀死进程</h2><p>杀死已经启动的程序和普通方式一样：</p>
<pre><code>pkill -<span class="number">9</span> <span class="property">name</span>
killall <span class="property">name</span>
kill pid
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://zgr0629.github.io/2015/04/27/服务器/Linux命令后台运行/" data-id="ci8zwxirw0005wchoi33vhk3f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/04/26/Mac/Mac下配置iTerm2+oh-my-zsh/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Mac下配置iTerm2+oh-my-zsh</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Safari/">Safari</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/call-chain-Javascript-链式调用/">call, chain , Javascript , 链式调用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/textarea-前端技术-大小自适应-自适应/">textarea , 前端技术 , 大小自适应 , 自适应</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阅读器/">阅读器</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Safari/" style="font-size: NaNpx;">Safari</a><a href="/tags/call-chain-Javascript-链式调用/" style="font-size: NaNpx;">call, chain , Javascript , 链式调用</a><a href="/tags/textarea-前端技术-大小自适应-自适应/" style="font-size: NaNpx;">textarea , 前端技术 , 大小自适应 , 自适应</a><a href="/tags/阅读器/" style="font-size: NaNpx;">阅读器</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">March 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">May 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/04/">April 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/03/">March 2012</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/04/27/服务器/Linux命令后台运行/">Linux命令后台运行</a>
          </li>
        
          <li>
            <a href="/2015/04/26/Mac/Mac下配置iTerm2+oh-my-zsh/">Mac下配置iTerm2+oh-my-zsh</a>
          </li>
        
          <li>
            <a href="/2015/04/25/Mac/Mac下免密码ssh远程主机/">Mac下免密码ssh远程主机</a>
          </li>
        
          <li>
            <a href="/2015/04/22/Mac/Mac下通过HomeBrew安装Nginx的坑/">Mac下通过HomeBrew安装Nginx的坑</a>
          </li>
        
          <li>
            <a href="/2013/03/26/服务器/PHP的单例模式/">PHP的单例模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Gary<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>